% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/base.R
\name{varimp_refit}
\alias{varimp_refit}
\title{Efficiently refitting certain vibr models}
\usage{
varimp_refit(
  vibr_fit,
  X,
  W = NULL,
  Y,
  delta = 0.1,
  verbose = TRUE,
  estimator = "AIPW",
  bounded = FALSE,
  updatetype = "weighted",
  estimand = "diff"
)
}
\arguments{
\item{vibr_fit}{a vibr_fit object}

\item{X}{data frame of variables for which variable importance will be estimated}

\item{W}{data frame of covariates (e.g. potential confounders) for which variable importance will not be estimated}

\item{Y}{outcome}

\item{delta}{change in each column of X corresponding to}

\item{verbose}{(logical) print extra information}

\item{estimator}{(character) "AIPW" (default), "TMLE", "GCOMP", "IPW" (note this function does not permit re-fitting cross-fit estimators)}

\item{bounded}{(logical) not used}

\item{updatetype}{(character) "weighted" or any other valid character. If "weighted" then uses weighting by clever covariate in update step of TMLE, otherwise fits a generalized linear model with no intercept and clever covariate as a fixed effect.}

\item{estimand}{(character) "diff" (default, estimate mean difference comparing Y under intervention with observed Y), "mean" (estimate mean Y under intervention)}
}
\value{
vibr_fit object
}
\description{
Refitting a variable importance model with outcome regression and propensity scores trained from another model. Works for any estimator which does not utilize sample splitting (i.e. cross-fit estimators)
}
\examples{

library(future)
currplan = plan()
plan(multisession) # fit models in parallel
data(metals, package="qgcomp")
XYlist = list(X=metals[,c(1:10, 15:23)], Y=metals$y)
Y_learners = .default_continuous_learners_big()
Xbinary_learners = .default_binary_learners_big()
Xdensity_learners = .default_density_learners_big()[c(1:4,6:7)]
vi <- varimp(X=XYlist$X,Y=XYlist$Y, delta=0.1, Y_learners = Y_learners,
       Xdensity_learners=Xdensity_learners, Xbinary_learners=Xbinary_learners,
       estimator="TMLE", updatetype="unweighted",estimand="diff")
vi
plan(currplan) # go back to standard evaluation
vi1 <- varimp_refit(vi, X=XYlist$X,Y=XYlist$Y, delta=0.1,
                    estimator="TMLE", updatetype="weighted", estimand="diff")
vi1
vi2 <- varimp_refit(vi, X=XYlist$X,Y=XYlist$Y, delta=0.1,
                    estimator="AIPW")
vi2
vi3 <- varimp_refit(vi, X=XYlist$X,Y=XYlist$Y, delta=0.1,
                    estimator="GCOMP", estimand="mean")
vi3
vi4 <- varimp_refit(vi, X=XYlist$X,Y=XYlist$Y, delta=0.1,
                    estimator="IPW")
vi4

# find the fit corresponding to calcium
caidx <- which(names(XYlist$X)=="calcium")
thidx <- which(names(XYlist$X)=="total_hardness")
# can confirm
# vi1$gfits[[caidx]]$training_task$nodes$outcome
calpredict = vi1$gfits[[caidx]]$predict()[[1]]
thpredict = vi1$gfits[[thidx]]$predict()[[1]]
# plot predicted density (not predicted value!) against original value,
# compare with kernel density
plot(metals$calcium, calpredict/max(calpredict), pch=19, cex=0.2,
  ylab="scaled conditional density")
lines(density(metals$calcium))
plot(metals$total_hardness, thpredict/max(thpredict), pch=19, cex=0.2,
  ylab="scaled conditional density")
lines(density(metals$total_hardness))
# note these are effectively measuring much of the same quantity
plot(metals$calcium, metals$total_hardness)
plot(calpredict, thpredict)

}
